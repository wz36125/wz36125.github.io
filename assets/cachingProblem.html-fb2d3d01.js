import{_ as a,o as e,c as r,a as h}from"./app-c9408cad.js";const n={},c=h('<h2 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h2><p><strong>缓存一致性</strong>：当数据库中的数据发生变化时，如果缓存中的数据没有及时更新，就会出现缓存数据和数据库数据不一致的情况。 <strong>缓存穿透</strong>：当请求查询一个一定不存在的数据，由于缓存是不命中时被动写，如果从数据库查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。 <img src="http://view.lixingyong.com/images/2024/03/22/cd1a1eafec1769cdbb1f18a0c9f888b2.png" alt=""><strong>缓存雪崩</strong>：缓存服务器宕机，或者大量的缓存同时过期，会导致大量的请求直接访问数据库，可能会导致数据库负载过大。 <img src="http://view.lixingyong.com/images/2024/03/22/c23eee03ccc55c270ee06a3c8cc3c574.png" alt=""><strong>缓存击穿</strong>：和缓存雪崩有点类似，当某个热点数据的缓存过期的瞬间，大量的请求可能会同时访问数据库，这也可能会导致数据库负载过大 <strong>内存资源限制</strong>：缓存数据是存储在内存中的，如果缓存的数据过多，可能会消耗大量的内存资源</p><h2 id="解决方式" tabindex="-1"><a class="header-anchor" href="#解决方式" aria-hidden="true">#</a> 解决方式</h2><p>解决方式有多种，在实际的开发中需要根据具体的业务需求选择合适的缓存策略和解决方案</p><h3 id="锁" tabindex="-1"><a class="header-anchor" href="#锁" aria-hidden="true">#</a> 锁</h3><p>单机锁 可使用 synchronized 标记接口 多台实例 可使用分布式锁 如 redis的setnx方式，来达成快速失败</p><h3 id="队列" tabindex="-1"><a class="header-anchor" href="#队列" aria-hidden="true">#</a> 队列</h3><h3 id="缓存降级" tabindex="-1"><a class="header-anchor" href="#缓存降级" aria-hidden="true">#</a> 缓存降级</h3><h2 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透" aria-hidden="true">#</a> 缓存穿透</h2><p>如果走了查询数据库，且结果是一个空数据，也将其保存起来，下个请求到达时 先判断数据是否存在， 且这个数据在设定的有效期内，则直接返回，避免查询数据库</p><h2 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩" aria-hidden="true">#</a> 缓存雪崩</h2><p>为缓存设置不同的过期时间，避免大量缓存数据同时失效； 使用缓存预热机制，在缓存失效之前将数据重新加载到缓存中； 使用分布式缓存，将缓存数据分散到多个节点上，避免单点故障；</p><h2 id="缓存击穿" tabindex="-1"><a class="header-anchor" href="#缓存击穿" aria-hidden="true">#</a> 缓存击穿</h2><p>使用互斥锁； 热点数据永不过期； 热点数据提前缓存预热； 使用熔断机制`</p>',14),i=[c];function t(d,s){return e(),r("div",null,i)}const l=a(n,[["render",t],["__file","cachingProblem.html.vue"]]);export{l as default};
