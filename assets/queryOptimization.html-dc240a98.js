import{_ as a,o as n,c as s,a as t}from"./app-c9408cad.js";const e={},p=t(`<h2 id="常见的缓存有哪些" tabindex="-1"><a class="header-anchor" href="#常见的缓存有哪些" aria-hidden="true">#</a> 常见的缓存有哪些？</h2><ol><li>mybatis 一级缓存</li><li>mybatis 二级缓存</li><li>本地缓存</li><li>分布式缓存：redis</li></ol><h2 id="mybatis一级缓存" tabindex="-1"><a class="header-anchor" href="#mybatis一级缓存" aria-hidden="true">#</a> mybatis一级缓存</h2><p>在调用查询语句的方法上面添加@Transactional</p><p>这样 参数未发生变化时 一直返回的缓存</p><p>如何全局关闭一级缓存？在配置文件中配置 mybatis.configuration.local-cache-scope 有两个值 statement 和 session，配置statement即可</p><h2 id="mybatis二级缓存" tabindex="-1"><a class="header-anchor" href="#mybatis二级缓存" aria-hidden="true">#</a> mybatis二级缓存</h2><p>打开需要缓存的mapper.xml，在 mapper namespace=&quot;com.xx.xx.xx.mapper.TrainMapper&quot; 的下方输入cache</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>com.xx.xx.xx.mapper.TrainMapper<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
	<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cache</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cache</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>它会以 namespace 为独立的区域，不同的mapper 即使操作的是同一张表，对应的缓存也是不同的区域，对同个 namespace 做增删改操作时，二级缓存会清空，<strong>即使这条sql没有改变任何数据，mybatis任然会清空缓存</strong></p><p>这时多次查询时 会在控制台看到 Cache Hit Ratio [命名空间] 0.5，没有输出sql语句，则是查询的缓存</p><p><strong>返回的实体类一定要序列化，implements Serializable 即可</strong></p><p><strong>缺点：会修改mybatis生成的类，会对依赖这些类的代码生成器影响使用，任意的增删改的操作都会清空缓存，对于查库存类似的业务作用不大，扣减/增加库存的操作很快很频繁；假如有多个服务节点，现在这些节点都执行了这条语句 且都有了二级缓存，此时执行一个删除语句，它只会走到这些服务节点的某一台，此时这台的缓存会被清除，而其他台还是有二级缓存的，下一次查询语句，如果还是这台 它会去数据库查询新的数据，而其它台还是返回的缓存数据，最终会导致这几台返回的数据不一样，这是非常致命的</strong></p><h2 id="springboot内置缓存-本地缓存" tabindex="-1"><a class="header-anchor" href="#springboot内置缓存-本地缓存" aria-hidden="true">#</a> springboot内置缓存(本地缓存)</h2><p>pom引入依赖</p><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>  
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>  
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-cache<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>并在启动类中 添加 @EnableCaching 注解</p><p>然后再在接口的方法上面添加 @Cacheable，并配置value，这个value代表着缓存空间，拿这里的值当key使用，建议以当前类名+当前方法名</p><p>执行这个方法后会缓存查询结果，下次执行这个方法时会直接返回结果，连这个方法的代码都不用执行，效率要比mybatis高</p><p>@CachePut 代表着当前这个方法执行后的结果 强制更新到指定的缓存空间中，它与 @Cacheable联合使用更高效</p><p><strong>缺点：和mybatis一样，缓存数据只在当前节点有效，多台节点缓存的数据不一致的问题，对多台节点的扩展和缩减影响较大</strong></p><h3 id="注解" tabindex="-1"><a class="header-anchor" href="#注解" aria-hidden="true">#</a> 注解</h3><p><strong>1. @EnableCaching</strong></p><p>用于开启缓存功能。该注解可以放在 Spring Boot 主类上，也可以放在需要使用缓存的类上。</p><p><strong>2. @Cacheable</strong></p><p>用于标注可以缓存的方法。被该注解标注的方法，其返回值将被缓存起来。</p><p><strong>3. @CachePut</strong></p><p>用于标注可以更新缓存的方法。被该注解标注的方法，其返回值将被更新到缓存中。</p><p><strong>4. @CacheEvict</strong></p><p>用于标注可以清除缓存的方法。被该注解标注的方法，将清除缓存中指定的数据。</p><p><strong>5. @Caching</strong></p><p>该注解是 @Cacheable、@CachePut 和 @CacheEvict 的组合注解。</p><h2 id="springboot整合redis-分布式" tabindex="-1"><a class="header-anchor" href="#springboot整合redis-分布式" aria-hidden="true">#</a> springboot整合redis(分布式)</h2><h3 id="引入依赖、配置" tabindex="-1"><a class="header-anchor" href="#引入依赖、配置" aria-hidden="true">#</a> 引入依赖、配置</h3><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>  
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>  
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">spring.data.redis.host</span><span class="token punctuation">=</span><span class="token value attr-value">xxx  </span>
<span class="token comment"># 默认6379</span>
<span class="token key attr-name">spring.data.redis.port</span><span class="token punctuation">=</span><span class="token value attr-value">6379</span>
<span class="token key attr-name">spring.data.redis.password</span><span class="token punctuation">=</span><span class="token value attr-value">xxx  </span>

<span class="token comment"># 如果使用spring自带的方式书写redis读写缓存，就将spring.cache.type改为redis</span>
<span class="token key attr-name">spring.cache.type</span><span class="token punctuation">=</span><span class="token value attr-value">redis  </span>
<span class="token key attr-name">spring.cache.redis.use-key-prefix</span><span class="token punctuation">=</span><span class="token value attr-value">true  </span>
<span class="token key attr-name">spring.cache.redis.key-prefix</span><span class="token punctuation">=</span><span class="token value attr-value">train_cache_</span>
<span class="token comment"># 是否允许存放空值 false为不允许</span>
<span class="token key attr-name">spring.cache.redis.cache-null-values</span><span class="token punctuation">=</span><span class="token value attr-value">false  </span>
<span class="token comment"># 数据过期时间</span>
<span class="token key attr-name">spring.cache.redis.time-to-live</span><span class="token punctuation">=</span><span class="token value attr-value">60s</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样配置后，就可以像springboot内置缓存那样写注解，且数据存放在redis当中，这样就不用担心存放的数据只在某个实例当中</p>`,37),c=[p];function i(l,o){return n(),s("div",null,c)}const u=a(e,[["render",i],["__file","queryOptimization.html.vue"]]);export{u as default};
