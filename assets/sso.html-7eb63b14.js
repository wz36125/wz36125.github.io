import{_ as e,o,c as t,a as d}from"./app-c9408cad.js";const r={},a=d('<h2 id="界面" tabindex="-1"><a class="header-anchor" href="#界面" aria-hidden="true">#</a> 界面</h2><p><img src="https://telegraph-image-8n8.pages.dev/file/b4318cc7caa34f02d6984.png" alt=""><img src="https://a08f43cb.telegraph-image-8n8.pages.dev/file/ddd8ba329e5c7be609df7.png" alt=""><img src="https://a08f43cb.telegraph-image-8n8.pages.dev/file/1de049e0507265e7800f8.png" alt=""><img src="https://a08f43cb.telegraph-image-8n8.pages.dev/file/70fe4cb8e2facff200b67.png" alt=""></p><p>本文以后端为主，前后端分离的项目</p><h2 id="后端" tabindex="-1"><a class="header-anchor" href="#后端" aria-hidden="true">#</a> 后端</h2><h3 id="技术栈" tabindex="-1"><a class="header-anchor" href="#技术栈" aria-hidden="true">#</a> 技术栈</h3><table><thead><tr><th>依赖名</th><th>版本号</th></tr></thead><tbody><tr><td>springboot</td><td>3.1.x</td></tr><tr><td>springbootweb</td><td>parent</td></tr><tr><td>lombok</td><td>1.18.x</td></tr><tr><td>redis</td><td>parent</td></tr><tr><td>hutool</td><td>5.8.x</td></tr></tbody></table><h3 id="理论" tabindex="-1"><a class="header-anchor" href="#理论" aria-hidden="true">#</a> 理论</h3><p><img src="https://a08f43cb.telegraph-image-8n8.pages.dev/file/3718bc84f2082146a22ca.jpg" alt=""><strong>单点登录（Single Sign-On，SSO）是指在多个应用系统中，用户只需登录一次就可以访问多个应用系统的能力。</strong><img src="https://a08f43cb.telegraph-image-8n8.pages.dev/file/75d0782297d6dbffffbe6.jpg" alt=""></p><p>此图中用户仅需在某个应用系统登录一次，即可访问其他应用系统，无需再次登录，除非token超过了配置的过期时间。</p><h3 id="开发思路" tabindex="-1"><a class="header-anchor" href="#开发思路" aria-hidden="true">#</a> 开发思路</h3><h4 id="认证服务" tabindex="-1"><a class="header-anchor" href="#认证服务" aria-hidden="true">#</a> 认证服务</h4><p>新建项目 取名为 sso-login 这个项目为 <code>认证服务</code> 各个服务应用都会调用这个服务</p><p>在这个应用服务当中 引入 <code>redis</code> 作为token的存储方式</p><p>lombok 引入是为了方便开发，使用<code>@Data</code>,<code>@NoArgsConstructor</code>,<code>@AllArgsConstructor</code> 不用写setter/getter、无参/有参构造器</p><p>由于该项目不是微服务 没有使用 <code>gateway</code>,实现<code>WebMvcConfigurer</code>、<code>HandlerInterceptor</code>接口 配置跨域</p><p>由于该项目仅做逻辑示例 所以没有使用到数据库，如mysql，用户信息存在服务内存当中</p><p>编写 controller 由于是示例项目 则把功能写在了controller 中</p><p>编写 login、info、logout、refresh 四个接口</p><p><strong>login</strong></p><p>负责用户登录、校验登录数据、生成/存储token、返回token、返回用户信息</p><p>生成token的方式是 使用JWT，生成新token时 <code>(hutool自带JWTUtil，仅需开发生成条件的函数)</code> 先在redis中查看当前用户的缓存是否存在，如果存在则删除</p><p>生成token时 需生成两个token 一个是短 <code>token</code> 一个是长<code>refreshToken</code>，短token用于访问接口，长token用于刷新token，如果长token过期则需要用户重新登录</p><p>对 <code>HttpServletResponse</code> 设置 token的cookie，注意 <code>setPath</code> 和 <code>setDomain</code>, 一般是 <code>/</code> 和 <code>engshop.com</code> 主域名</p><p><strong>info</strong></p><p>验证短<code>token</code>, 是否过期，是则返回401，否则继续判断长<code>token</code>是否过期，过期则返回401，否则返回用户信息</p><p><strong>refresh</strong></p><p>验证长<code>token</code>，是否过期，过期则返回401 重新登录，否则生成新的短<code>token</code>，返回生成新的短<code>token</code></p><p><strong>logout</strong></p><p>设置 <code>HttpServletResponse</code> cookie <code>setMaxAge</code> 为0，清空 和 <code>token</code> 有关的 <code>redis</code> 缓存数据</p><h4 id="其它服务" tabindex="-1"><a class="header-anchor" href="#其它服务" aria-hidden="true">#</a> 其它服务</h4><p>由于本项目没有使用<code>feign</code> 则是通过 <code>restTemplate</code> 调用 <code>认证服务</code> 的接口，最终获取到用户信息</p><h2 id="前端" tabindex="-1"><a class="header-anchor" href="#前端" aria-hidden="true">#</a> 前端</h2><h3 id="技术栈-1" tabindex="-1"><a class="header-anchor" href="#技术栈-1" aria-hidden="true">#</a> 技术栈</h3><table><thead><tr><th>依赖名</th><th>版本号</th></tr></thead><tbody><tr><td>vue</td><td>3.x</td></tr><tr><td>vuetify</td><td>3.x</td></tr><tr><td>axios</td><td>1.4.0</td></tr></tbody></table><h3 id="开发" tabindex="-1"><a class="header-anchor" href="#开发" aria-hidden="true">#</a> 开发</h3><p>新建web项目 <code>sso-main</code> 映射域名为 <code>www.engshop.com</code> 作为主页</p><p>新建web项目 <code>sso-login</code> 映射域名为 <code>login.engshop.com</code> 作为登录页</p><p>新建web项目 <code>sso-vip</code> 映射域名为 <code>vip.engshop.com</code> 作为会员管理页</p><p>新建web项目 <code>sso-cart</code> 映射域名为 <code>cart.engshop.com</code> 作为购物车页</p><p>以上所以web项目始终保持根域名一致的情况下 才能共享cookie</p><p>token 自动刷新的几个要点</p><p>我这里采用的是 验证不通过统一返回 401，然后在<code>axios</code>的<code>response</code>拦截器中 进行判断，如果返回的状态码是401，则拿长token去 <code>认证服务</code> 请求短token，拿到短token后 重新请求之前没有成功的请求</p><p><strong>不能单纯的判断401，就重新去请求刷新短token，有可能连长token都没有</strong></p><p><strong>在请求刷新短token时，需等待短token刷新完成，才能重新请求之前没有成功的请求</strong></p><p><strong>如果以上点 没有注意到的话 会造成一直在无效的重复请求 死循环</strong></p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p><strong>当 X应用服务调用 认证服务接口验证不通过时 采用的是快速结束当前请求，由前端自动调用刷新短token的接口，成功后自动重新请求之前的业务请求的方式， 而不是在 验证不通过的时候 认证服务接口自动刷新短token</strong></p><p><strong>如果节省成本，那么可以考虑其它应用不和 <code>认证服务</code> 进行通讯，用户在<code>认证服务</code>登录后 返回的token里面包含用户信息，且其它应用服务能够自己验证token，这样就不用每次访问某个应用时这个应用就得向<code>认证服务</code>进行验证， 这样某个应用进行扩容时，<code>认证服务</code> 也就不用跟着扩容了，压力也就变小了</strong></p><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h3><p><strong>将认证逻辑和业务逻辑分离，使得系统的职责更加清晰，也更容易进行单元测试和维护。同时，这种策略也能提高系统的响应速度，因为在认证失败时，系统会立即结束当前请求，而不会等待认证服务刷新token。</strong></p><p><strong>且对用户的控制力很强，比如让某用户下线</strong></p><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h3><p><strong>如果某个应用的流量体量很庞大 得扩容这个应用服务时，认证服务也得扩容，因为用户状态信息全在认证服务这边。也就是说如果子系统流量很大，认证服务的压力也很大，还得给认证服务做容灾。</strong></p><p><strong>成本大，肯花钱 体验好</strong></p><p><strong>如果前端在刷新token后不能正确地重新发起之前的业务请求，用户可能会遇到一些问题。此外，这种策略也要求前端能够正确处理认证失败的情况</strong></p>',55),c=[a];function n(s,p){return o(),t("div",null,c)}const i=e(r,[["render",n],["__file","sso.html.vue"]]);export{i as default};
